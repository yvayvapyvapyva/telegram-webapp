<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="utf-8">
    <title>Route Editor - Readable JSON</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <script src="https://api-maps.yandex.ru/2.1/?apikey=YANDEX_API_KEY&lang=ru_RU"></script>
    <style>
        body, html { margin: 0; height: 100%; font-family: 'Inter', Arial, sans-serif; overflow: hidden; }
        #map { position: absolute; inset: 0; }
        #panel { 
            position: absolute; top: 10px; right: 10px; width: 300px; z-index: 1000;
            background: rgba(255,255,255,0.9); padding: 15px; border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2); backdrop-filter: blur(10px);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            max-height: 90vh; overflow-y: auto;
        }
        #panel.collapsed { transform: translateX(calc(100% + 20px)); opacity: 0; pointer-events: none; }
        #togglePanel {
            position: absolute; bottom: 25px; right: 20px; z-index: 1001;
            width: 50px; height: 50px; border-radius: 25px; border: none;
            background: #2f80ed; color: white; font-size: 24px; cursor: pointer;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3); display: flex; align-items: center; justify-content: center;
        }
        .info { background: #f4f4f7; padding: 10px; border-radius: 8px; margin-bottom: 8px; font-size: 12px; color: #444; line-height: 1.4; }
        .row { display: flex; gap: 8px; margin-bottom: 8px; }
        button { 
            flex: 1; cursor: pointer; border: none; border-radius: 8px; padding: 10px 5px; 
            background: #2f80ed; color: white; font-weight: bold; font-family: inherit;
            min-height: 44px; display: flex; align-items: center; justify-content: center;
        }
        button.active-draw { background: #28a745; box-shadow: 0 0 10px rgba(40,167,69,0.5); }
        button.danger { background: #e74c3c; }
        button.secondary { background: #6c757d; }
        button.add-btn { background: #28a745; max-width: 44px; font-size: 20px; }
        button.gh-btn { background: #28a745; font-size: 14px; } 
        textarea, .gh-input, select { 
            flex: 1; padding: 10px; border: 1px solid #ddd; border-radius: 8px; 
            outline: none; font-size: 14px; font-family: inherit; width: 100%; box-sizing: border-box;
        }
        .label-text { font-size: 11px; color: #777; margin-bottom: 3px; display: block; }
        #palette { display: flex; gap: 6px; margin-top: 5px; overflow-x: auto; padding: 5px 2px; }
        #palette div { min-width: 28px; height: 28px; border-radius: 6px; cursor: pointer; border: 1px solid #ccc; flex-shrink: 0; }
        .cmd-bubble {
            position: relative; background: #ffffff; border: 2px solid #333;
            border-radius: 6px; padding: 4px 8px; font-size: 12px;
            font-weight: bold; color: #000; box-shadow: 2px 2px 6px rgba(0,0,0,0.3);
            display: inline-block; min-width: 20px; max-width: 200px; 
            word-wrap: break-word; white-space: normal; line-height: 1.3;
        }
    </style>
</head>
<body>

<div id="map"></div>
<button id="togglePanel" onclick="document.getElementById('panel').classList.toggle('collapsed')">‚â°</button>

<div id="panel">
    <div class="row">
        <button onclick="rotate(-10)">‚ü≤ -10¬∞</button>
        <button onclick="rotate(10)">‚ü≥ +10¬∞</button>
    </div>
    
    <div class="row">
        <button id="drawBtn" onclick="toggleLineEditor()" class="secondary">üõ§Ô∏è –ü—É—Ç—å —Ç–æ—á–∫–∏</button>
    </div>
    
    <div style="margin-bottom: 8px;">
        <span class="label-text">–ö–æ–º–∞–Ω–¥–∞ —Ç–æ—á–∫–∏:</span>
        <textarea id="cmdInput" placeholder="–ö–æ–º–∞–Ω–¥–∞..." oninput="autoResize(this)" onblur="saveFields()"></textarea>
    </div>
    <div style="margin-bottom: 8px;">
        <span class="label-text">–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π:</span>
        <textarea id="commentInput" placeholder="–õ—é–±–æ–π —Ç–µ–∫—Å—Ç..." style="background: #fff9e6;" oninput="autoResize(this)" onblur="saveFields()"></textarea>
    </div>
    
    <div class="info">
        <input type="password" id="ghToken" class="gh-input" placeholder="GitHub Token" style="margin-bottom: 5px;" oninput="saveToken(this.value)">
        <div class="row">
            <select id="fileSelector" onchange="loadFromGitHub(this.value)">
                <option value="">–í—ã–±–µ—Ä–∏—Ç–µ —Ñ–∞–π–ª...</option>
            </select>
            <button class="add-btn" onclick="createNewFile()" title="–°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π —Ñ–∞–π–ª">+</button>
        </div>
    </div>

    <div id="coordsInfo" class="info">–ù–∞–∂–º–∏—Ç–µ –Ω–∞ –∫–∞—Ä—Ç—É</div>
    <div class="row" style="margin-bottom: 5px;"><div id="palette"></div></div>
    
    <div class="row">
        <button class="secondary" onclick="toggleLabels()">üëÅÔ∏è</button>
        <button class="danger" onclick="removePoint()">üóëÔ∏è</button>
        <button class="secondary" onclick="exportJSON()">üíæ</button>
        <button class="secondary" onclick="importJSON()">üìÇ</button>
    </div>
    <div class="row">
        <button class="gh-btn" style="width:100%" onclick="saveToGitHub()">üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –≤ GitHub</button>
    </div>
</div>

<script>
const GH_REPO = "yvayvapyvapyva/test";
const GH_PATH = "roads";

let map, points = [], current = null, showLabels = false, currentFileSha = null, selectedFilePath = null, userMarker = null;
const COLOR_PALETTE = ['Gold', 'blue', 'red', 'Lime', 'Fuchsia', 'purple', 'Silver', 'Aqua'];
const COLOR_MAP = { 'Gold': '#FFD700', 'blue': '#0000FF', 'red': '#FF0000', 'Lime': '#00FF00', 'Fuchsia': '#FF00FF', 'purple': '#800080', 'Silver': '#C0C0C0', 'Aqua': '#00FFFF' };

const f6 = (n) => Math.round(n * 1000000) / 1000000;

ymaps.ready(() => {
    map = new ymaps.Map("map", { center: [56.3399, 43.9332], zoom: 18, type: 'yandex#satellite', controls: [] });
    map.events.add('click', e => {
        if (current && current.polyline && current.polyline.editor.state === 'drawing') return;
        const p = addPoint(e.get('coords'));
        selectPoint(p);
    });
    
    const pal = document.getElementById('palette');
    COLOR_PALETTE.forEach(c => {
        const d = document.createElement('div');
        d.style.background = c;
        d.onclick = () => { if(current) { current.color = c; updateMarkers(); if(current.polyline) current.polyline.options.set('strokeColor', COLOR_MAP[c]); } };
        pal.appendChild(d);
    });
    startGeolocation(); initApp();
});

function addPoint(coords) {
    const p = { 
        id: points.length + 1, lat: f6(coords[0]), lon: f6(coords[1]), 
        azimuth: 0, color: 'Gold', command: '', comment: '', freePath: [], pm: null, polyline: null 
    };
    p.pm = new ymaps.Placemark(coords, { iconContent: "" }, {
        iconLayout: 'default#imageWithContent', iconImageSize: [40, 40], iconImageOffset: [-20, -20], draggable: true,
        iconImageHref: getIcon(p.azimuth, p.color, false, p.id), iconContentOffset: [25, -10],
        iconContentLayout: ymaps.templateLayoutFactory.createClass('{% if properties.iconContent %}<div class="cmd-bubble">$[properties.iconContent]</div>{% endif %}')
    });
    p.pm.events.add('drag', () => {
        const c = p.pm.geometry.getCoordinates();
        p.lat = f6(c[0]); p.lon = f6(c[1]);
        syncLineWithMarker(p); updateUI();
    });
    p.pm.events.add('click', () => selectPoint(p));
    map.geoObjects.add(p.pm);
    points.push(p);
    return p;
}

function selectPoint(p) {
    if (current && current !== p) { saveFields(); if (current.polyline) current.polyline.editor.stopEditing(); }
    current = p;
    document.getElementById('cmdInput').value = p.command || '';
    document.getElementById('commentInput').value = p.comment || '';
    document.getElementById('drawBtn').classList.remove('active-draw');
    autoResize(document.getElementById('cmdInput'));
    autoResize(document.getElementById('commentInput'));
    updateMarkers(); updateUI();
}

function syncLineWithMarker(p) {
    if (p.polyline) {
        let coords = p.polyline.geometry.getCoordinates();
        if (coords.length > 0) {
            coords[0] = [f6(p.lat), f6(p.lon)];
            p.polyline.geometry.setCoordinates(coords);
        }
    }
}

function toggleLineEditor() {
    if (!current) return alert("–í—ã–±–µ—Ä–∏—Ç–µ —Ç–æ—á–∫—É");
    if (!current.polyline) {
        current.polyline = new ymaps.Polyline([[f6(current.lat), f6(current.lon)]], {}, {
            strokeColor: COLOR_MAP[current.color] || '#FFD700', strokeWidth: 4, editorDrawingCursor: "crosshair"
        });
        map.geoObjects.add(current.polyline);
    }
    const editor = current.polyline.editor;
    const btn = document.getElementById('drawBtn');
    if (btn.classList.contains('active-draw')) {
        editor.stopEditing();
        btn.classList.remove('active-draw');
        current.freePath = current.polyline.geometry.getCoordinates().map(c => [f6(c[0]), f6(c[1])]);
    } else {
        syncLineWithMarker(current);
        if (current.polyline.geometry.getCoordinates().length <= 1) editor.startDrawing();
        else editor.startEditing();
        btn.classList.add('active-draw');
    }
}

function saveFields() { 
    if (current) { 
        current.command = document.getElementById('cmdInput').value.trim(); 
        current.comment = document.getElementById('commentInput').value.trim(); 
        current.pm.properties.set('iconContent', showLabels ? current.command : ""); 
    } 
}

function rotate(deg) { if (current) { current.azimuth = (current.azimuth + deg + 360) % 360; updateMarkers(); updateUI(); } }

function removePoint() {
    if (!current) return;
    if (current.polyline) map.geoObjects.remove(current.polyline);
    map.geoObjects.remove(current.pm);
    points = points.filter(p => p !== current);
    current = null; 
    points.forEach((p, i) => { p.id = i + 1; updateMarkers(); });
}

function updateMarkers() { points.forEach(p => p.pm.options.set('iconImageHref', getIcon(p.azimuth, p.color, p === current, p.id))); }
function updateUI() { if (current) document.getElementById('coordsInfo').innerHTML = `<b>ID:${current.id}</b> | ‚à†${current.azimuth}¬∞<br>${current.lat}, ${current.lon}`; }

function getIcon(az, col, sel, id) {
    return 'data:image/svg+xml;utf8,' + encodeURIComponent(`<svg xmlns="http://www.w3.org/2000/svg" width="40" height="40"><g transform="rotate(${az},20,20)"><polygon points="20,2 35,35 20,26 5,35" fill="${col}" stroke="${sel?'#2ecc71':'#000'}" stroke-width="${sel?3:1.5}"/></g><circle cx="20" cy="20" r="9" fill="white" stroke="${col}" stroke-width="2"/><text x="20" y="24" font-size="11" font-family="Arial" font-weight="900" text-anchor="middle">${id}</text></svg>`);
}

function toggleLabels() { showLabels = !showLabels; points.forEach(p => p.pm.properties.set('iconContent', showLabels ? p.command : "")); }
function autoResize(el) { el.style.height = 'auto'; el.style.height = (el.scrollHeight) + 'px'; }

function getCleanData() {
    return points.map(p => ({
        id: p.id,
        lat: f6(p.lat),
        lon: f6(p.lon),
        azimuth: p.azimuth,
        color: p.color,
        command: p.command,
        comment: p.comment || "",
        freePath: (p.polyline ? p.polyline.geometry.getCoordinates() : p.freePath).map(c => [f6(c[0]), f6(c[1])])
    }));
}

async function saveToGitHub() {
    if (!selectedFilePath) return alert("–§–∞–π–ª –Ω–µ –≤—ã–±—Ä–∞–Ω");
    saveFields();
    const token = document.getElementById('ghToken').value;
    const readableJson = JSON.stringify(getCleanData(), null, 2);
    try {
        const res = await fetch(`https://api.github.com/repos/${GH_REPO}/contents/${selectedFilePath}`, {
            method: 'PUT', headers: { 'Authorization': `token ${token}` },
            body: JSON.stringify({ 
                message: "Update route", 
                content: btoa(unescape(encodeURIComponent(readableJson))), 
                sha: currentFileSha 
            })
        });
        if (res.ok) { currentFileSha = (await res.json()).content.sha; alert("–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ!"); }
    } catch (e) { alert("–û—à–∏–±–∫–∞ GitHub"); }
}

async function loadFromGitHub(path) {
    if(!path) return;
    const token = document.getElementById('ghToken').value;
    try {
        const res = await fetch(`https://api.github.com/repos/${GH_REPO}/contents/${path}`, { headers: { 'Authorization': `token ${token}` } });
        const data = await res.json();
        currentFileSha = data.sha; selectedFilePath = path;
        renderData(JSON.parse(decodeURIComponent(escape(atob(data.content)))));
    } catch(e) { alert("–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏"); }
}

function renderData(json) {
    points.forEach(p => { if(p.polyline) map.geoObjects.remove(p.polyline); map.geoObjects.remove(p.pm); });
    points = [];
    json.forEach((d, i) => {
        const p = addPoint([d.lat, d.lon]); // –ü—Ä–æ—Å—Ç–æ —Å–æ–∑–¥–∞–µ–º
        p.id = d.id || (i + 1); 
        p.azimuth = d.azimuth || 0; 
        p.color = d.color || 'Gold'; 
        p.command = d.command || ''; 
        p.comment = d.comment || '';
        p.freePath = d.freePath || [];
        p.pm.properties.set('iconContent', showLabels ? p.command : "");
        if (p.freePath.length > 0) {
            p.polyline = new ymaps.Polyline(p.freePath, {}, { strokeColor: COLOR_MAP[p.color] || '#FFD700', strokeWidth: 4 });
            map.geoObjects.add(p.polyline);
        }
    });
    updateMarkers();
    if (points.length > 0) selectPoint(points[0]); // –í—ã–±–∏—Ä–∞–µ–º —Ç–æ–ª—å–∫–æ –≤ –∫–æ–Ω—Ü–µ
}

async function listGitHubFiles(token) {
    const sel = document.getElementById('fileSelector');
    try {
        const res = await fetch(`https://api.github.com/repos/${GH_REPO}/contents/${GH_PATH}`, { headers: { 'Authorization': `token ${token}` } });
        const files = await res.json();
        sel.innerHTML = '<option value="">–í—ã–±–µ—Ä–∏—Ç–µ —Ñ–∞–π–ª...</option>';
        files.filter(f => f.name.endsWith('.json')).forEach(f => {
            const o = document.createElement('option'); o.value = f.path; o.textContent = f.name; sel.appendChild(o);
        });
    } catch(e) {}
}

async function createNewFile() {
    const token = document.getElementById('ghToken').value;
    let name = prompt("–ò–º—è —Ñ–∞–π–ª–∞:"); if (!name) return;
    if (!name.endsWith('.json')) name += '.json';
    await fetch(`https://api.github.com/repos/${GH_REPO}/contents/${GH_PATH}/${name}`, {
        method: 'PUT', headers: { 'Authorization': `token ${token}` },
        body: JSON.stringify({ message: "New", content: btoa("[]") })
    });
    listGitHubFiles(token);
}

function exportJSON() {
    saveFields();
    const a = document.createElement('a');
    a.href = URL.createObjectURL(new Blob([JSON.stringify(getCleanData(), null, 2)], {type: 'application/json'}));
    a.download = 'route.json'; a.click();
}

function importJSON() {
    const input = document.createElement('input'); input.type = 'file';
    input.onchange = e => {
        const reader = new FileReader();
        reader.onload = () => renderData(JSON.parse(reader.result));
        reader.readAsText(e.target.files[0]);
    };
    input.click();
}

function saveToken(v) { localStorage.setItem('gh_token', v); if(v.length > 10) listGitHubFiles(v); }
function initApp() { const t = localStorage.getItem('gh_token'); if(t){ document.getElementById('ghToken').value = t; listGitHubFiles(t); } }

function startGeolocation() {
    if ("geolocation" in navigator) {
        navigator.geolocation.watchPosition(p => {
            const coords = [p.coords.latitude, p.coords.longitude];
            if (!userMarker) {
                userMarker = new ymaps.Placemark(coords, {}, { preset: 'islands#geolocationIcon', zIndex: 2000 });
                map.geoObjects.add(userMarker);
            } else userMarker.geometry.setCoordinates(coords);
        }, null, { enableHighAccuracy: true });
    }
}
</script>
</body>
</html>
